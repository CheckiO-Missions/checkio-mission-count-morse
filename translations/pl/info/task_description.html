<!-- Describe task in general -->

<p style="text-align: justify;">
    Każdy z Państwa z pewnością słyszał o alfabecie Morse'a, klasycznym kodowaniu tekstu za pomocą symboli binarnych, kanonicznie oznaczanych kropkami i myślnikami. Kodowanie to jest jednak technicznie trójskładnikowe, ponieważ pauza między dwiema literami jest tak naprawdę oddzielnym symbolem, analogicznie do tego, jak białe znaki między słowami, które teraz Państwo czytają, są znakami takimi samymi jak te z widocznymi glifami. Bez pauz oddzielających poszczególne słowa kodowe, ta sama wiadomość mogłaby teoretycznie zostać zdekodowana na wykładniczo wiele różnych sposobów. 
</p>

<p style="text-align: justify;">
    Państwa funkcja otrzymuje <b>message</b> bez pauz wraz z <b>letters</b>, którego kodowanie pierwotnie wygenerowało ten <b>message</b>. Funkcja powinna policzyć, ile różnych permutacji tych <b>letters</b> daje dokładnie ten sam <b>message</b>. Każdy pojedynczy znak może pojawić się w literach co najwyżej raz, wszystkie symbole i litery muszą zostać użyte. 
</p>



<!-- <p style="text-align: center;">
  <img title="example" src="{{MEDIA}}example.png" alt="example" style="max-height: 83px"/>
</p> -->

<!-- Explain input and output values -->
<p>
   <strong>Dane wejściowe:</strong> Dwa argumenty: Wiadomość zakodowana alfabetem Morse'a i sekwencja liter jako ciągi znaków <span>(str{% if is_js %}ing{% endif %})</span>.
</p>

<p>
   <strong>Wyjście:</strong> Liczba permutacji jako liczba całkowita <span>({% if is_js %}number{% else %}int{% endif %})</span>. 
</p>


<p>
    <strong>Przykłady:</strong>
</p>
<pre class="brush: {% if is_js %}javascript{% else %}python{% endif %}">{{init_code_tmpl}}</pre>

<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<!-- <p class="for_info_only">
    <strong>How it’s used:</strong>
    <i>(math is used everywhere)</i>
</p> -->

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<p>
    <strong>Warunek wstępny:</strong>
    <ul>
    <li><i>len(set(letters)) == len(letters)</i></li>
    </ul>
</p>

<p>
    <i>
        To zadanie pochodzi z kursu CCPS 109 Computer Science I, wersja z 21 grudnia 2022, prowadzonego przez <a target="_blank" href="https://github.com/ikokkari">Ilkka Kokkarinen</a>.
    </i>
</p>

<details>
    <summary><i>Hej, pss! Proszę kliknąć tutaj, aby uzyskać małą podpowiedź od autora, jeśli jej potrzebujesz.</i></summary>
    <p>
        Jednym ze sposobów rozwiązania jest użycie rekurencji, wspomaganej smaczną porcją magii <b>@lru_cache</b>, aby zapobiec niepotrzebnemu wielokrotnemu badaniu identycznych podproblemów.
    </p>
</details>
